#!/usr/bin/env python
import argparse
import subprocess
import datetime
import sys
import time
import os
import shutil

from itertools import repeat


EMSDK_GIT_REPO = 'https://github.com/kripken/emscripten/'
DOCKER_REPO = "trzeci/emscripten"
SDK_MIN = "1.36.6"
QUEUE_FILE = "queue.txt"

def is_version_at_least(ver, target):
    ver = ver.split('.')
    target = target.split('.')
    while len(ver) < len(target):
        ver += ['0']
    for i in range(len(ver)):
        if int(ver[i]) < int(target[i]):
            return False
        elif int(ver[i]) > int(target[i]):
            return True
    return True


def get_tags():
    tags = subprocess.check_output(["git", 'ls-remote', '--tags', EMSDK_GIT_REPO])
    all_tags = []

    for t in tags.split('\n'):
        try:
            t = t[t.index('refs/tags/') + len('refs/tags/'):].strip()
            if is_version_at_least(t, SDK_MIN):
                all_tags += [t]
        except:
            pass
    return all_tags

def version_compare(x, y):
    a = 1 if is_version_at_least(x, y) else 0
    b = 1 if is_version_at_least(y, x) else 0
    return a - b

def log(text):
    with open("log.txt", "a") as myfile:
        myfile.write("\n[{time}] {text}".format(time=datetime.datetime.now(), text=text))
    print(text)

def get_builds(tags, update=False, branches=False, releases=False, b32=False, b64=False):
    result = []

    bit_versions = []
    if b32: bit_versions.append("32bit")
    if b64: bit_versions.append("64bit")

    for bits in bit_versions:
        if releases:
            for tag in tags:
                sdk = "sdk-tag-" + tag + "-" + bits
                result.append({
                    "tag": tag,
                    "dir": "tag-" + tag,
                    "sdk": sdk,
                    "docker_tag": sdk,
                    "docker_name" : DOCKER_REPO + ":" + sdk,
                    "update" : update,
                })
        if branches:
            for branch in ["incoming", "master"]:
                sdk = "sdk-" + branch + "-" + bits
                result.append({
                    "tag": branch,
                    "dir": branch,
                    "sdk": sdk,
                    "docker_tag": sdk,
                    "docker_name" : DOCKER_REPO + ":" + sdk,
                    "update" : True,
                })

    return result

def get_server_tags():
    from urllib import urlopen
    import json

    api = "https://registry.hub.docker.com/v1/repositories/{repo}/tags".format(repo=DOCKER_REPO)
    response = urlopen(api)
    data = json.loads(str(response.read()))
    result = {}
    for node in data:
        result[str(node["name"])] = {
            "layer" : str(node["layer"])
        }
    return result

def generate_dockerfile(path, build):
    f = open("Dockerfile.in", "r")
    data = f.read()
    f.close()
    properties = {
        "EMSCRIPTEN_TAG" : build["tag"],
        "EMSCRIPTEN_SDK" : build["sdk"],
        "EMSCRIPTEN_SDK_DIR" : build["dir"]
    }
    for p in properties:
        data = data.replace("{" + p + "}", properties[p])
    f = open(path, "w")
    f.write(data)
    f.close()

def rename(builds):
    for pb in builds:
        if pb.startswith("sdk"):
            log("Already OK: " + pb)
            continue
        tag = "sdk-tag-" + pb + "-32bit"
        if tag in builds:
            log("Already Exists: " + pb)
            continue

        log("[INFO] RETAG: " + pb  + " => " + tag)
        subprocess.call(["docker", "pull", DOCKER_REPO + ":" + pb])
        subprocess.call(["docker", "tag", DOCKER_REPO + ":" + pb, DOCKER_REPO + ":" + tag])
        subprocess.call(["docker", "push", DOCKER_REPO + ":" + tag])
        subprocess.call(["docker", "rmi", "-f", DOCKER_REPO + ":" + pb])
        subprocess.call(["docker", "rmi", "-f", DOCKER_REPO + ":" + tag])

def push_tag(tag):
    for i in repeat(None, 3):
        if subprocess.call(["docker", "push", tag]):
            log("[WARNING] Pushing {tag} failed. Repeat.".format(tag=tag))
        else:
            log("[INFO] Pushed tag: {tag} ".format(tag=tag))
            subprocess.call(["docker", "rmi", "-f", tag])
            return
    log("[ERROR] Pushing {tag} failed.".format(tag=tag))

def generate(builds, serverTags, autopush):
    for build in builds:
        if build["docker_tag"] in serverTags:
            if build["update"]:
                log("[INFO] Update tag: " + build["docker_tag"])
            else:
                log("[INFO] Not need to create " + build["docker_tag"])
                continue

        log("[INFO] Start building {tag}".format(tag=build["docker_tag"]))

        generate_dockerfile("Dockerfile", build)
        
        if not os.path.exists("configs/" + build["docker_tag"]):
            os.makedirs("configs/" + build["docker_tag"])
        shutil.copy("Dockerfile", "configs/" + build["docker_tag"])
        

        # generate docker image 
        if subprocess.call(["docker", "build", "-t",  build["docker_name"], "."]):
            log("[ERROR] Building {tag} failed".format(tag=build["docker_tag"]))
            continue

        # test image by compiling sample.cpp
        t_start = datetime.datetime.now()

        test_successed = True
        tests = [
            "emcc test.cpp -o test.js && node test.js",
            "make --version",
            "cmake --version",
        ]

        for test in tests:
            print("Perform test `%s`" + test)
            if subprocess.call(["docker run -v $(pwd):/src " + build["docker_name"]+ " " + test], shell=True):
                log("[ERROR] Testing {tag} failed".format(tag=build["docker_tag"]))
                test_successed = False
                break
            else:
                print("OK")

        if not test_successed:
            continue

        log("[INFO] Compiling [{tag}] in: {time}".format(tag=build["docker_tag"], time=str(datetime.datetime.now() - t_start)))

        # push to docker repository
        if autopush:
            push_tag(build["docker_name"])
        else:
            with open(QUEUE_FILE, 'w+') as f:
                data = f.read().splitlines(True)
                data.insert(0, build["docker_name"] + "\n")
                f.writelines(data)
                log("[INFO] Defered pushing tag: {tag} ".format(tag=build["docker_name"]))

        log("[INFO] Finished building {tag}".format(tag=build["docker_tag"]))



def monitor_and_push():
    print("Waiting for something to push...")
    while True:
        if os.path.exists(QUEUE_FILE):
            with open(QUEUE_FILE, 'r') as fin:
                data = fin.read().splitlines(True)
            if len(data):
                tag_to_send = data[0].strip()
                with open(QUEUE_FILE, 'w') as fout:
                    fout.writelines(data[1:])
                if tag_to_send:
                    push_tag(tag_to_send)
        time.sleep(2)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Emscripten Image generator')
    parser.add_argument("tags", type=str, nargs='*', help="Explicitly provide list of tags in format X.Y.Z, i.e.: 1.34.5")
    parser.add_argument("--no-32", action="store_false", help="Explicitly disable 32 images")
    parser.add_argument("--no-64", action="store_false", help="Explicitly disable 64 images")
    parser.add_argument("--update", action="store_true", help="Update docker images that are arleady created and pushed")
    parser.add_argument("--branches", action="store_true", help="Update master and incomming images")
    parser.add_argument("--releases", action="store_true", help="Update released SDKs")
    parser.add_argument("--pusher", action="store_true", help="Pushes tags created by regular command")

    args = parser.parse_args(sys.argv)
    if args.pusher:
        monitor_and_push()
    else:
        # list of raw tags like: 1.34.4...
        tags = get_tags()
        sorted(tags, cmp=version_compare)

        # list of build description: 
        # {
        #   'update': True, 
        #   'tag': '1.37.4', 
        #   'docker_name': 'trzeci/emscripten:sdk-tag-1.37.4-64bit', 
        #   'docker_tag': 'sdk-tag-1.37.4-64bit', 
        #   'dir': 'tag-1.37.4', 
        #   'sdk': 'sdk-tag-1.37.4-64bit'
        # }
        builds = get_builds(tags, args.update, args.branches, args.releases, args.no_32, args.no_64)
        # if len(args.tags)
        args.tags = args.tags[1:]

        # if tag was given explicitly, then use it
        if len(args.tags):
            for build in builds:
                build["update"] = build["tag"] in args.tags

        # List of pushed tags to Docker, in format:
        # 'sdk-master-32bit': {'layer': ''}
        pushed_builds = get_server_tags()

        # Execute compilation process
        generate(builds, pushed_builds, False)
