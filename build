#!/usr/bin/env python2

import argparse
import subprocess
import datetime
import time
import os
import json

from urllib import urlopen
from itertools import repeat

# TODO: https://github.com/jwilder/docker-squash


EMSDK_GIT_REPO = "https://github.com/kripken/emscripten/"
DOCKER_REGISTRY = "registry.hub.docker.com"
DOCKER_REPO = "trzeci/emscripten"

SDK_MIN = "1.36.6"
QUEUE_FILE = "queue.txt"
LOG_COMPILATION = "build.log"
LOG_STEPS = "steps.log"


# Utils ------------------------------------------------------------------------

def log(text):
    with open(LOG_STEPS, "a") as myfile:
        myfile.write("\n[{time}] {text}".format(time=datetime.datetime.now(), text=text))
    print(text)

def version_compare(x, y):
    a = 1 if is_version_at_least(x, y) else 0
    b = 1 if is_version_at_least(y, x) else 0
    return a - b

def is_version_at_least(ver, target):
    ver = ver.split('.')
    target = target.split('.')
    while len(ver) < len(target):
        ver += ['0']
    for i in range(len(ver)):
        if int(ver[i]) < int(target[i]):
            return False
        elif int(ver[i]) > int(target[i]):
            return True
    return True

#  Emscripten Helpers ----------------------------------------------------------

class EmscriptenHelper:
    @staticmethod
    def get_sdk_name_tag(tag, bits):
        return "sdk-tag-{tag}-{bits}bit".format(tag=tag, bits=bits)

    @staticmethod
    def get_sdk_name_branch(branch, bits):
        return "sdk-{branch}-{bits}bit".format(branch=branch, bits=bits)


    @staticmethod
    def get_emscripten_tags(min_version):
        tags = subprocess.check_output(["git", 'ls-remote', '--tags', EMSDK_GIT_REPO]).decode("utf-8").strip().split("\n")
        all_tags = []
        for t in tags:
            try:
                t = t[t.index('refs/tags/') + len('refs/tags/'):].strip()
                if is_version_at_least(t, min_version):
                    all_tags += [t]
            except:
                pass
        sorted(all_tags, cmp=version_compare)
        return all_tags


class EmscriptenTester:
    @staticmethod
    def test_image(id, remove_image=False):
        test_successed = True
        tests = [
            "emcc src/test.cpp -o src/test.js && node src/test.js",
            "emcc src/test.cpp -o src/test.js && node src/test.js",
            "emcc src/test.cpp -o src/test.js --closure 1 && node src/test.js",
            "java -version",
            "make --version",
            "cmake --version",
        ]

        if subprocess.call(["docker pull {id}".format(id=id)], shell=True):
            print("[ERROR] Image wasn't pulled and it's not stored locally")
            return False

        for test in tests:
            print("Perform test `%s`" % test)
            print("[TEST] %s" % test)
            if subprocess.call(["docker run --rm -v $(pwd):/src {id} {test}".format(id=id, test=test)], shell=True):
                log("[ERROR] Testing {id} failed".format(id=id))
                print("-- ERROR")
                test_successed = False
            else:
                print("-- OK")

        if remove_image:
            subprocess.call(["docker rmi {id}".format(id=id)], shell=True)

        return test_successed


class DockerHelper:
    @staticmethod
    def get_server_tags(repo):
        api = "https://{registry}/v1/repositories/{repo}/tags".format(repo=repo, registry=DOCKER_REGISTRY)
        response = urlopen(api)
        data = json.loads(str(response.read()))
        result = {}
        for node in data:
            result[str(node["name"])] = {
                "layer" : str(node["layer"])
            }
        return result

# --------------VV------------- NOT REFACTORED YET --------------VV------------- 

def get_builds(tags, update=False, branches=False, releases=False, b32=False, b64=False):
    result = []

    bit_versions = []
    bit_versions.append("32") if b32 else None
    bit_versions.append("64") if b64 else None

    for bits in bit_versions:
        if releases:
            for tag in tags:
                sdk = EmscriptenHelper.get_sdk_name_tag(tag, bits)
                result.append({
                    "tag": tag,
                    "dir": "tag-" + tag,
                    "sdk": sdk,
                    "docker_tag": sdk,
                    "docker_name" : DOCKER_REPO + ":" + sdk,
                    "update" : update,
                })
        if branches:
            for branch in ["incoming", "master"]:
                sdk = EmscriptenHelper.get_sdk_name_branch(branch, bits)
                result.append({
                    "tag": branch,
                    "dir": branch,
                    "sdk": sdk,
                    "docker_tag": sdk,
                    "docker_name" : DOCKER_REPO + ":" + sdk,
                    "update" : True,
                })

    return result

# def generate_dockerfile(path, build):
#     f = open("template/Dockerfile", "r")
#     data = f.read()
#     f.close()
#     properties = {
#         "EMSCRIPTEN_TAG" : build["tag"],
#         "EMSCRIPTEN_SDK" : build["sdk"],
#         "EMSCRIPTEN_SDK_DIR" : build["dir"]
#     }
#     for p in properties:
#         data = data.replace("{" + p + "}", properties[p])
#     f = open(path, "w")
#     f.write(data)
#     f.close()

def rename(builds):
    for pb in builds:
        if pb.startswith("sdk"):
            log("Already OK: " + pb)
            continue
        tag = "sdk-tag-" + pb + "-32bit"
        if tag in builds:
            log("Already Exists: " + pb)
            continue

        log("[INFO] RETAG: " + pb  + " => " + tag)
        subprocess.call(["docker", "pull", DOCKER_REPO + ":" + pb])
        subprocess.call(["docker", "tag", DOCKER_REPO + ":" + pb, DOCKER_REPO + ":" + tag])
        subprocess.call(["docker", "push", DOCKER_REPO + ":" + tag])
        subprocess.call(["docker", "rmi", "-f", DOCKER_REPO + ":" + pb])
        subprocess.call(["docker", "rmi", "-f", DOCKER_REPO + ":" + tag])

def push_tag(tag):
    for i in repeat(None, 3):
        if subprocess.call(["docker", "push", tag]):
            log("[WARNING] Pushing {tag} failed. Repeat.".format(tag=tag))
        else:
            log("[INFO] Pushed tag: {tag} ".format(tag=tag))
            subprocess.call(["docker", "rmi", "-f", tag])
            # TODO: docker ps --filter "status=exited" | grep 'hours ago' | awk '{print $1}' | xargs --no-run-if-empty docker rm
            return
    log("[ERROR] Pushing {tag} failed.".format(tag=tag))

def generate(builds, serverTags, autopush):
    for build in builds:
        if build["docker_tag"] in serverTags:
            if build["update"]:
                log("[INFO] Update tag: " + build["docker_tag"])
            else:
                log("[INFO] Not need to create " + build["docker_tag"])
                continue

        log("[INFO] Start building {tag}".format(tag=build["docker_tag"]))


        # --build-arg
        # config_dir = os.path.join("configs", build["docker_tag"])
        # docker_file = os.path.join(config_dir, "Dockerfile")

        # if not os.path.exists(config_dir):
            # os.makedirs(config_dir)

        # generate_dockerfile(docker_file, build)
        
        config_dir = "."
        docker_file = "Dockerfile"
        # generate docker image 
        if subprocess.call([
                "docker", 
                "build", 
                "-t",  build["docker_name"],
                "--build-arg", "EMSCRIPTEN_TAG="+build["tag"], 
                "--build-arg", "EMSCRIPTEN_SDK="+build["sdk"], 
                "--build-arg", "EMSCRIPTEN_SDK_DIR="+build["dir"], 
                config_dir
            ]):
            log("[ERROR] Building {tag} failed".format(tag=build["docker_tag"]))
            continue

        # test image by compiling sample.cpp
        t_start = datetime.datetime.now()

        if not EmscriptenTester.test_image(build["docker_name"]):
            continue

        log("[INFO] Compiling [{tag}] in: {time}".format(tag=build["docker_tag"], time=str(datetime.datetime.now() - t_start)))

        # push to docker repository
        if autopush:
            push_tag(build["docker_name"])
        else:
            with open(QUEUE_FILE, 'w+') as f:
                data = f.read().splitlines(True)
                data.insert(0, build["docker_name"] + "\n")
                f.writelines(data)
                log("[INFO] Defered pushing tag: {tag} ".format(tag=build["docker_name"]))

        log("[INFO] Finished building {tag}".format(tag=build["docker_tag"]))

# ------------------------------------------------------------------------------

def build(args):
    """Build images, and push tags to the queue"""

    tags = EmscriptenHelper.get_emscripten_tags(SDK_MIN)

    # list of build description: 
    # {
    #   'update': True, 
    #   'tag': '1.37.4', 
    #   'docker_name': 'trzeci/emscripten:sdk-tag-1.37.4-64bit', 
    #   'docker_tag': 'sdk-tag-1.37.4-64bit', 
    #   'dir': 'tag-1.37.4', 
    #   'sdk': 'sdk-tag-1.37.4-64bit'
    # }
    builds = get_builds(tags, args.update, args.branches, args.releases, args.no_32, args.no_64)

    # if tag was given explicitly, then use it
    if len(args.tags):
        for build in builds:
            build["update"] = build["tag"] in args.tags
    # List of pushed tags to Docker, in format:
    # 'sdk-master-32bit': {'layer': ''}
    pushed_builds = DockerHelper.get_server_tags(DOCKER_REPO)

    # Execute compilation process
    generate(builds, pushed_builds, False)

def test(args):
    """Run tests"""
    for tag in args.tags:
        EmscriptenTester.test_image((args.project or DOCKER_REPO) + ":" + tag, args.spotless)
        
    
def push(args):
    """Push creted tags, what are waiting in queue document """
    while True:
        if os.path.exists(QUEUE_FILE):
            with open(QUEUE_FILE, 'r') as fin:
                data = fin.read().splitlines(True)
            if len(data):
                tag_to_send = data[0].strip()
                with open(QUEUE_FILE, 'w') as fout:
                    fout.writelines(data[1:])
                if tag_to_send:
                    push_tag(tag_to_send)
        time.sleep(2)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Emscripten Image generator')
    subparsers = parser.add_subparsers(title="command", help="Main work command")

    parser_build = subparsers.add_parser("build", help="Build images")
    parser_build.set_defaults(function=build)
    parser_build.add_argument("tags", type=str, nargs='*', help="Explicitly provide list of tags in format X.Y.Z, i.e.: 1.34.5")
    parser_build.add_argument("--no-32", action="store_false", help="Explicitly disable 32 images")
    parser_build.add_argument("--no-64", action="store_false", help="Explicitly disable 64 images")
    parser_build.add_argument("--update", action="store_true", help="Update docker images that are arleady created and pushed")
    parser_build.add_argument("--branches", action="store_true", help="Update master and incomming images")
    parser_build.add_argument("--releases", action="store_true", help="Update released SDKs")
    
    parser_test = subparsers.add_parser("test", help="Test given tag(s) with Emscripten and WebAssembly compatibility")
    parser_test.set_defaults(function=test)
    parser_test.add_argument("tags", type=str, nargs='*', help="List of docker tags to test")
    parser_test.add_argument("--spotless", action="store_true", help="Remove used image")
    parser_test.add_argument("--project", help="Custom docker project")

    parser_push = subparsers.add_parser("push", help="Runs a service what will push created images")
    parser_push.set_defaults(function=push)

    # parser.add_argument("--pusher", action="store_true", help="Pushes tags created by regular command")
    args = parser.parse_args()
    args.function(args)
